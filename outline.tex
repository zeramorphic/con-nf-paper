To construct a model of tangled type theory, we build each type individually, and then prove that the resulting structure satisfies the required axioms.
The process for building each type is complicated, and depends on some knowledge about the construction of the previous types.
In the following subsections, we outline the construction the types, as well as the precise facts we need to carry through the inductive hypothesis at each stage.

\subsection{Model parameters}
\label{ss:outline:params}

As described in \cref{ss:theories:ttt}, the types of a given model of tangled type theory are indexed by a limit ordinal \( \lambda \).
Our model will also have two more cardinal parameters, denoted \( \kappa \) and \( \mu \), satisfying \( \lambda < \kappa < \mu \).

Sets smaller than size \( \kappa \) will be called \emph{small}.
We require that \( \kappa \) is a regular cardinal; this ensures that small-indexed unions of small sets are small.
Note that \( \aleph_0 \) is small.

Each type in our model will have size \( \mu \).
We require \( \mu \) to be a strong limit cardinal; power sets of sets smaller than \( \mu \) must also be smaller than \( \mu \).
We stipulate that the cofinality of \( \mu \) is at least \( \kappa \).
This assumption will become important whenever we consider objects indexed by small ordinals.

We remark that these constraints are satisfiable; \( \lambda = \aleph_0, \kappa = \aleph_1, \mu = \beth_{\omega_1} \) suffice.

\subsection{Atoms and permutations}
\label{ss:outline:atoms}

To aid our construction, we will add an additional level of objects below type zero.
These will not be a part of the final model we construct.
This base type will be comprised of objects called \emph{atoms} (although they are not atoms in the traditional model-theoretic sense).

Alongside the construction of the types of our model, we will also construct a collection of permutations of each type, called the \emph{allowable permutations}.
Such permutations will preserve the structure of the model in a strong sense; for instance, they preserve membership.

\subsection{Construction of each type}
\label{ss:outline:construction}

Objects in our model are defined by their elements at all lower type indices.
However, not all collections of extensions may become model elements; for example, they may fail to satisfy extensionality at all levels simultaneously.
We impose two restrictions on what kind of extensions an object may have.

The first restriction is that one of the extensions of a given object must be `preferred', and every other extension must be easily derivable from that particular extension.
This will help us to establish extensionality, as model elements will be the same if and only if their preferred extensions are the same.
The system to compute other extensions uses a construction called the \emph{fuzz} map.
This map turns information about one extension into `ordered junk' in another extension, in such a way that the model cannot learn anything useful about the non-preferred extensions.
Our allowable permutations will be defined as a set of permutations that respect the fuzz map.

The second restriction is that the object must have a small \emph{support} comprised of \emph{addresses}.
That is, the behaviour of the object under the action of allowable permutations must be fully characterisable by the behaviour of a small set of addresses under allowable permutations.
This will ensure that the objects of our model are not too complex.
Because the cofinality of \( \mu \) is at least \( \kappa \), there are only \( \mu \) small sets of elements taken from a collection of size \( \mu \); this observation will play a key role in establishing the sizes of our types.

\subsection{Constraining the size of each type}
\label{ss:outline:size}

The construction of a given type can only be done under the assumption that each smaller type was of size exactly \( \mu \).
This means that we need to prove that each type has size \( \mu \) in the inductive step.
In order to do this, we will need to show that there are a lot of allowable permutations.
The main theorem establishing this, called the \emph{freedom of action theorem}, roughly states that under certain assumptions, a permutation defined on a small set of addresses can be extended to an allowable permutation.
The majority of this paper will be allocated to proving the freedom of action theorem, and it will be outlined in more detail when we are in a position to prove it.
One this is established, we can prove that the size of each type is precisely \( \mu \) by carefully counting the possible ways to describe a model element.

\subsection{Finishing the induction}
\label{ss:outline:finishing}

We can then finish the inductive step and build the entire model.
It remains to show that this is a model of TTT as desired.
This part of the proof is quite direct, and also uses the freedom of action theorem.
