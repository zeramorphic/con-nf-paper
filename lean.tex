\subsection{Lean and its type theory}

Lean \cite{lean} is a functional programming language and interactive theorem prover.
As indicated in \cref{s:overview}, its underlying logic is a dependent type theory based on the calculus of constructions.
Carneiro proved in \cite{leantt} that Lean's type theory is consistent relative to
\[ \mathsf{ZFC} + \{ \text{there are } n \text{ inaccessible cardinals} \mid n < \omega \} \]
These inaccessible cardinals are needed to support Lean's hierarchy of type universes.
Higher universes are commonly used whenever they are convenient, for example in definitions of cardinals and ordinals.
However, these uses are not strictly necessary for our purposes, and the entire proof can be carried out in plain \( \mathsf{ZFC} \), as shown by \cite{holmes2023nf} and this paper.

Proofs in Lean may be written in its \emph{tactic mode}, which tracks hypotheses and goals, and enables the use of \emph{tactics} to update these hypotheses and goals according to logical rules.
There are a large variety of tactics to perform different tasks, such as simplification (\texttt{simp}), rewriting of subexpressions (\texttt{rw}), structural induction (\texttt{induction}), and so on.
These tactics output a \emph{proof term}, which is a term in Lean's underlying type theory.
The type of this term corresponds to the proposition that we intend to prove under the Curry--Howard correspondence.
The proof term is then passed to Lean's \emph{kernel}, which contains a type-checking algorithm.
If the proof term generated by a tactic has the correct type, the kernel accepts the proof.

\subsection{Trusting Lean}

% Lean's kernel is the only code that must be `trusted' in order to guarantee that a proof accepted by Lean as a whole is correct, since any unsound tactics would output a proof term that is not type-correct.

Lean is a large project, but one need only trust its kernel to ensure that accepted proofs are correct.
If a tactic were to output an incorrect proof term, then the kernel would have the opportunity to find this mistake before the proof were to be accepted.

It is important to note that the kernel has no way of knowing whether a formal definition written in Lean matches the familiar mathematical definition.
Any definitions used in a theorem statement must be manually checked by a human reader; all that Lean guarantees is that the conclusion is correct as written in its own type theory.
For example, if verifying a formalised proof of Fermat's last theorem, one should manually check the definitions of natural numbers, addition, exponentiation, and so on, but need not check (for example) definitions and results about elliptic curves.

All of the proofs in this paper (except in \cref{s:theories}, upon which no other results depend) are verified by Lean.
To help with the verification step, our main result can be found in the \texttt{Result.lean} file (\href{https://github.com/leanprover-community/con-nf/blob/main/ConNF/Model/Result.lean}{source}, \href{https://leanprover-community.github.io/con-nf/doc/ConNF/Model/Result.html}{documentation}).
Each result is tagged with a hyperlink (such as \lean{ConNF.ext}) to the documentation generated from the corresponding Lean code.
